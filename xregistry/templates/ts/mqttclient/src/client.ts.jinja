{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import * as mqtt from 'mqtt';
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(root) %}
{%- if uses_cloudevents_message %}
import { CloudEvent, HTTP } from 'cloudevents';
{%- endif %}
import { v4 as uuidv4 } from 'uuid';

// Import data types (need to compile data project first: cd ../{{ data_project_name }} && npm install && npm run build)
// NOTE: In real usage, the data project should be a proper npm package dependency
import * as {{ data_project_name }} from '../../{{ data_project_name }}/dist/index.js';

{% for messagegroupid, messagegroup in messagegroups.items() -%}
{%- set groupname = messagegroupid | pascal -%}
{%- set class_name = (groupname | strip_namespace) + "MqttClient" %}

/**
 * MQTT client for the `{{ messagegroupid }}` message group.
 */
export class {{ class_name }} {
    private client: mqtt.MqttClient;
    
    {%- for messageid, message in messagegroup.messages.items() %}
    {%- set messagename = messageid | strip_namespace | pascal %}
    {%- set message_body_type = util.body_type(data_project_name, root, message) %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    
    /**
     * Handler for {{ messagename }} messages
     {%- if message.description %}
     * {{ message.description }}
     {%- endif %}
     */
    public {{ messagename }}Handler?: ({% if isCloudEvent %}cloudEvent: CloudEvent, {% endif %}data: {{ message_body_type }}) => Promise<void>;
    {%- endfor %}
    
    /**
     * Constructor
     * @param brokerUrl The MQTT broker URL (e.g., 'mqtt://localhost:1883')
     * @param options MQTT connection options
     */
    constructor(brokerUrl: string, options?: mqtt.IClientOptions) {
        this.client = mqtt.connect(brokerUrl, options);
        
        this.client.on('connect', () => {
            console.log('Connected to MQTT broker');
        });
        
        this.client.on('error', (error) => {
            console.error('MQTT client error:', error);
        });
        
        this.client.on('message', async (topic, message) => {
            await this.handleMessage(topic, message);
        });
    }
    
    /**
     * Subscribe to topics for all message types
     */
    async subscribe(): Promise<void> {
        return new Promise((resolve, reject) => {
            const topics: string[] = [
                {% for messageid, message in messagegroup.messages.items() -%}
                '{{ messageid }}',
                {% endfor %}
            ];
            
            this.client.subscribe(topics, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    }
    
    /**
     * Handle incoming MQTT message
     */
    private async handleMessage(topic: string, payload: Buffer): Promise<void> {
        {%- if uses_cloudevents_message %}
        // Try to parse as CloudEvent
        try {
            const cloudEvent = HTTP.toEvent({ body: payload.toString(), headers: {} });
            await this.dispatchCloudEvent(cloudEvent);
            return;
        } catch {
            // Not a CloudEvent, treat as plain message
        }
        {%- endif %}
        
        await this.dispatchMessage(topic, payload);
    }
    
    {%- if uses_cloudevents_message %}
    
    /**
     * Dispatch a CloudEvent message
     */
    private async dispatchCloudEvent(cloudEvent: CloudEvent): Promise<void> {
        const cloudEventType = cloudEvent.type;
        
        switch (cloudEventType) {
            {% for messageid, message in messagegroup.messages.items() -%}
            {%- set messagename = messageid | pascal | strip_namespace %}
            {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
            {%- set message_body_type = util.body_type(data_project_name, root, message) %}
            {%- if isCloudEvent %}
            case '{{ messageid }}':
                if (this.{{ messagename }}Handler) {
                    const data = cloudEvent.data as {{ message_body_type }};
                    await this.{{ messagename }}Handler(cloudEvent, data);
                }
                break;
            {%- endif %}
            {% endfor %}
            default:
                break;
        }
    }
    {%- endif %}
    
    /**
     * Dispatch a plain MQTT message
     */
    private async dispatchMessage(topic: string, payload: Buffer): Promise<void> {
        switch (topic) {
            {% for messageid, message in messagegroup.messages.items() if not cloudEvents.isCloudEvent(message) -%}
            {%- set messagename = messageid | pascal | strip_namespace %}
            {%- set message_body_type = util.body_type(data_project_name, root, message) %}
            case '{{ messageid }}':
                if (this.{{ messagename }}Handler) {
                    const data = JSON.parse(payload.toString()) as {{ message_body_type }};
                    await this.{{ messagename }}Handler(data);
                }
                break;
            {% endfor %}
            default:
                break;
        }
    }
    
    {% for messageid, message in messagegroup.messages.items() -%}
    {%- set messagename = messageid | pascal | strip_namespace %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    {%- set type_name = util.body_type(data_project_name, root, message) %}
    
    /**
     * Publish the `{{ messagename }}` message
     {%- if message.description %}
     * {{ message.description }}
     {%- endif %}
     * @param data The message data object
     * @returns Promise that resolves when the message is published
     */
    async publish{{ messagename }}(data: {{ type_name }}): Promise<void> {
        return new Promise((resolve, reject) => {
            {%- if isCloudEvent %}
            const cloudEvent = new CloudEvent({
                type: '{{ messageid }}',
                source: '/client',
                id: uuidv4(),
                data: data,
                datacontenttype: 'application/json'
            });
            
            const payload = JSON.stringify(cloudEvent.toJSON());
            {%- else %}
            const payload = JSON.stringify(data);
            {%- endif %}
            
            this.client.publish('{{ messageid }}', payload, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    }
    {% endfor %}
    
    /**
     * Close the MQTT client
     */
    async close(): Promise<void> {
        return new Promise((resolve) => {
            this.client.end(false, {}, () => {
                resolve();
            });
        });
    }
}
{% endfor %}
