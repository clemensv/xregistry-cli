{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import { ServiceBusClient, ServiceBusSender, ServiceBusMessage } from '@azure/service-bus';
import { TokenCredential, DefaultAzureCredential } from '@azure/identity';
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(root) %}
{%- if uses_cloudevents_message %}
import { CloudEvent, HTTP } from 'cloudevents';
{%- endif %}
import { v4 as uuidv4 } from 'uuid';

// Import data types (need to compile data project first: cd ../{{ data_project_name }} && npm install && npm run build)
// NOTE: In real usage, the data project should be a proper npm package dependency
import * as {{ data_module_name }} from '../../{{ data_project_name }}/dist/index.js';

{% for messagegroupid, messagegroup in messagegroups.items() -%}
{%- set groupname = messagegroupid | pascal -%}
{%- set class_name = (groupname | strip_namespace) + "Producer" %}

/**
 * Producer class to send messages in the `{{ messagegroupid }}` message group.
 */
export class {{ class_name }} {
    private client: ServiceBusClient;
    private sender: ServiceBusSender;
    private mode: 'binary' | 'structured';
    private format: string;
    
    /**
     * Constructor for queue
     * @param client The Azure Service Bus client
     * @param queueName The queue name
     * @param mode CloudEvents binding mode: 'binary' or 'structured' (default: 'structured')
     * @param format CloudEvents format for structured mode (default: 'application/json')
     */
    constructor(client: ServiceBusClient, queueName: string, mode?: 'binary' | 'structured', format?: string);
    
    /**
     * Constructor for topic
     * @param client The Azure Service Bus client
     * @param topicName The topic name
     * @param isQueue Set to false for topic
     * @param mode CloudEvents binding mode: 'binary' or 'structured' (default: 'structured')
     * @param format CloudEvents format for structured mode (default: 'application/json')
     */
    constructor(client: ServiceBusClient, topicOrQueueName: string, isQueue?: boolean, mode?: 'binary' | 'structured', format?: string);
    
    constructor(
        client: ServiceBusClient, 
        topicOrQueueName: string, 
        isQueueOrMode: boolean | 'binary' | 'structured' = true,
        modeOrFormat?: 'binary' | 'structured' | string,
        formatParam?: string
    ) {
        this.client = client;
        this.sender = client.createSender(topicOrQueueName);
        
        // Handle overloaded constructor parameters
        if (typeof isQueueOrMode === 'boolean') {
            this.mode = (modeOrFormat as 'binary' | 'structured') || 'structured';
            this.format = formatParam || 'application/json';
        } else {
            this.mode = isQueueOrMode;
            this.format = (modeOrFormat as string) || 'application/json';
        }
    }
    
    {%- if root.endpoints %}
    {%- for endpointid, endpoint in root.endpoints.items() %}
    {%- if endpoint.usage and "producer" in endpoint.usage %}
    {%- set protocol = endpoint.protocol | lower %}
    {%- if protocol == "amqp" %}
    {%- set options = endpoint.protocoloptions %}
    {%- set endpoints = endpoint.endpoints %}
    
    /**
     * Create a new instance for the {{ endpointid }} endpoint
     * @param credential The Azure credential to use for authentication
     * @param fullyQualifiedNamespace The fully qualified namespace
     * @param queueOrTopicName The queue or topic name
     * @returns A new instance of {{ class_name }}
     */
    static createFor{{ endpointid | pascal | strip_namespace }}(
        credential?: TokenCredential,
        fullyQualifiedNamespace?: string,
        queueOrTopicName?: string
    ): {{ class_name }} {
        const cred = credential || new DefaultAzureCredential();
        const ns = fullyQualifiedNamespace || {% if endpoints %}'{{ endpoints[0].uri }}'{% else %}''{% endif %};
        const name = queueOrTopicName || {% if options and 'node' in options %}'{{ options['node'] }}'{% else %}''{% endif %};
        
        if (!ns) {
            throw new Error('fullyQualifiedNamespace is required');
        }
        if (!name) {
            throw new Error('queueOrTopicName is required');
        }
        
        const client = new ServiceBusClient(ns, cred);
        return new {{ class_name }}(client, name);
    }
    {%- endif %}
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    
    {% for messageid, message in messagegroup.messages.items() -%}
    {%- set messagename = messageid | pascal | strip_namespace %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    {%- set type_name = util.body_type(data_project_name, root, message) %}
    
    /**
     * Send the `{{ messagename }}` message
     {%- if message.description %}
     * {{ message.description }}
     {%- endif %}
     * @param data The message data object
     {%- if isCloudEvent %}
     {%- for attrname in ['source', 'type'] if attrname not in message.envelopemetadata %}
     * @param {{ attrname }} CloudEvent required attribute '{{ attrname }}'
     {%- endfor %}
     {%- for attrname, attribute in message.envelopemetadata.items() if attribute.type == "uritemplate" %}
     {%- for placeholder in attribute.value | regex_search('\\{([A-Za-z0-9_]+)\\}') %}
     * @param {{ placeholder }} Value for placeholder {{ placeholder }} in attribute {{ attrname }}
     {%- endfor %}
     {%- endfor %}
     {%- for attrname, attribute in message.envelopemetadata.items() if attribute.value is not defined and attrname not in ["time", "id", "datacontenttype", "dataschema"] %}
     * @param {{ attrname }} CloudEvent {{ attrname }} attribute{% if not attribute.required %} (optional){% endif %}
     {%- endfor %}
     {%- endif %}
     * @param contentType The content type of the message data
     * @returns Promise that resolves when the message is sent
     */
    async send{{ messagename }}(
        data: {{ type_name }},
        {%- if isCloudEvent %}
        {%- for attrname in ['source', 'type'] if attrname not in message.envelopemetadata %}
        {{ attrname }}: string,
        {%- endfor %}
        {%- for attrname, attribute in message.envelopemetadata.items() if attribute.type == "uritemplate" %}
        {%- for placeholder in attribute.value | regex_search('\\{([A-Za-z0-9_]+)\\}') %}
        {{ placeholder }}: string,
        {%- endfor %}
        {%- endfor %}
        {%- for attrname, attribute in message.envelopemetadata.items() if attribute.value is not defined and attrname not in ["time", "id", "datacontenttype", "dataschema"] %}
        {{ attrname }}{% if not attribute.required %}?{% endif %}: string,
        {%- endfor %}
        {%- endif %}
        contentType: string = 'application/json'
    ): Promise<void> {
        {%- if isCloudEvent %}
        const cloudEvent = new CloudEvent({
        {%- for attrname in ['source', 'type'] if attrname not in message.envelopemetadata %}
        {%- if attrname == "type" %}
            type: {{ attrname }},
        {%- elif attrname == "source" %}
            source: {{ attrname }},
        {%- endif %}
        {%- endfor %}
        {%- for attrname, attribute in message.envelopemetadata.items() %}
        {%- if attrname == "type" %}
            type: {% if attribute.value %}'{{ attribute.value }}'{% else %}{{ attrname }}{% endif %},
        {%- elif attrname == "source" %}
            source: {% if attribute.value %}{% if attribute.type == "uritemplate" %}`{{ attribute.value | regex_replace('\\{([A-Za-z0-9_]+)\\}', '${\\1}') }}`{% else %}'{{ attribute.value }}'{% endif %}{% else %}{{ attrname }} || '/producer'{% endif %},
        {%- elif attrname in ["id", "time"] %}
            {# id and time are auto-generated #}
        {%- elif attrname == "datacontenttype" %}
            {# handled separately #}
        {%- elif attrname == "dataschema" %}
            {# handled separately if needed #}
        {%- elif attribute.value %}
            {{ attrname }}: {% if attribute.type == "uritemplate" %}`{{ attribute.value | regex_replace('\\{([A-Za-z0-9_]+)\\}', '${\\1}') }}`{% else %}'{{ attribute.value }}'{% endif %},
        {%- else %}
            {% if not attribute.required %}...({{ attrname }} && { {{ attrname }} }),{% else %}{{ attrname }},{% endif %}
        {%- endif %}
        {%- endfor %}
            id: uuidv4(),
            data: data,
            datacontenttype: contentType
        });
        
        let message: ServiceBusMessage;
        if (this.mode === 'structured') {
            message = {
                body: cloudEvent.toJSON(),
                contentType: this.format
            };
        } else {
            // Binary content mode
            message = {
                body: data,
                contentType: contentType,
                applicationProperties: {
                    'ce_specversion': '1.0',
                    'ce_id': cloudEvent.id,
                    'ce_type': cloudEvent.type,
                    'ce_source': cloudEvent.source
                }
            };
            
            {%- for attrname, attribute in message.envelopemetadata.items() %}
            {%- if attrname not in ["id", "type", "source", "specversion", "datacontenttype", "data"] %}
            if (cloudEvent.{{ attrname }}) {
                message.applicationProperties!['ce_{{ attrname }}'] = String(cloudEvent.{{ attrname }});
            }
            {%- endif %}
            {%- endfor %}
        }
        {%- else %}
        const message: ServiceBusMessage = {
            body: data,
            subject: '{{ messageid }}',
            contentType: contentType
        };
        {%- endif %}
        
        await this.sender.sendMessages(message);
    }
    
    /**
     * Send multiple `{{ messagename }}` messages in a batch
     * @param dataArray Array of message data objects
     {%- if isCloudEvent %}
     {%- for attrname in ['source', 'type'] if attrname not in message.envelopemetadata %}
     * @param {{ attrname }} CloudEvent required attribute '{{ attrname }}'
     {%- endfor %}
     {%- for attrname, attribute in message.envelopemetadata.items() if attribute.type == "uritemplate" %}
     {%- for placeholder in attribute.value | regex_search('\\{([A-Za-z0-9_]+)\\}') %}
     * @param {{ placeholder }} Value for placeholder {{ placeholder }} in attribute {{ attrname }}
     {%- endfor %}
     {%- endfor %}
     {%- for attrname, attribute in message.envelopemetadata.items() if attribute.value is not defined and attrname not in ["time", "id", "datacontenttype", "dataschema"] %}
     * @param {{ attrname }} CloudEvent {{ attrname }} attribute{% if not attribute.required %} (optional){% endif %}
     {%- endfor %}
     {%- endif %}
     * @param contentType The content type of the message data
     * @returns Promise that resolves when all messages are sent
     */
    async send{{ messagename }}Batch(
        dataArray: {{ type_name }}[],
        {%- if isCloudEvent %}
        {%- for attrname in ['source', 'type'] if attrname not in message.envelopemetadata %}
        {{ attrname }}: string,
        {%- endfor %}
        {%- for attrname, attribute in message.envelopemetadata.items() if attribute.type == "uritemplate" %}
        {%- for placeholder in attribute.value | regex_search('\\{([A-Za-z0-9_]+)\\}') %}
        {{ placeholder }}: string,
        {%- endfor %}
        {%- endfor %}
        {%- for attrname, attribute in message.envelopemetadata.items() if attribute.value is not defined and attrname not in ["time", "id", "datacontenttype", "dataschema"] %}
        {{ attrname }}{% if not attribute.required %}?{% endif %}: string,
        {%- endfor %}
        {%- endif %}
        contentType: string = 'application/json'
    ): Promise<void> {
        const messages: ServiceBusMessage[] = dataArray.map(data => {
            {%- if isCloudEvent %}
            const cloudEvent = new CloudEvent({
            {%- for attrname in ['source', 'type'] if attrname not in message.envelopemetadata %}
            {%- if attrname == "type" %}
                type: {{ attrname }},
            {%- elif attrname == "source" %}
                source: {{ attrname }},
            {%- endif %}
            {%- endfor %}
            {%- for attrname, attribute in message.envelopemetadata.items() %}
            {%- if attrname == "type" %}
                type: {% if attribute.value %}'{{ attribute.value }}'{% else %}{{ attrname }}{% endif %},
            {%- elif attrname == "source" %}
                source: {% if attribute.value %}{% if attribute.type == "uritemplate" %}`{{ attribute.value | regex_replace('\\{([A-Za-z0-9_]+)\\}', '${\\1}') }}`{% else %}'{{ attribute.value }}'{% endif %}{% else %}{{ attrname }} || '/producer'{% endif %},
            {%- elif attrname in ["id", "time"] %}
                {# id and time are auto-generated #}
            {%- elif attrname == "datacontenttype" %}
                {# handled separately #}
            {%- elif attrname == "dataschema" %}
                {# handled separately if needed #}
            {%- elif attribute.value %}
                {{ attrname }}: {% if attribute.type == "uritemplate" %}`{{ attribute.value | regex_replace('\\{([A-Za-z0-9_]+)\\}', '${\\1}') }}`{% else %}'{{ attribute.value }}'{% endif %},
            {%- else %}
                {% if not attribute.required %}...({{ attrname }} && { {{ attrname }} }),{% else %}{{ attrname }},{% endif %}
            {%- endif %}
            {%- endfor %}
                id: uuidv4(),
                data: data,
                datacontenttype: contentType
            });
            
            if (this.mode === 'structured') {
                return {
                    body: cloudEvent.toJSON(),
                    contentType: this.format
                };
            } else {
                const applicationProperties: Record<string, any> = {
                    ce_specversion: '1.0',
                    ce_id: cloudEvent.id,
                    ce_type: cloudEvent.type,
                    ce_source: cloudEvent.source
                };
                if (cloudEvent.subject) applicationProperties.ce_subject = cloudEvent.subject;
                if (cloudEvent.time) applicationProperties.ce_time = cloudEvent.time;
                {%- for attrname, attribute in message.envelopemetadata.items() if attrname not in ["id", "type", "source", "subject", "time", "specversion", "datacontenttype", "dataschema", "data"] %}
                if ((cloudEvent as any).{{ attrname }}) applicationProperties.ce_{{ attrname }} = (cloudEvent as any).{{ attrname }};
                {%- endfor %}
                return {
                    body: data,
                    contentType: contentType,
                    applicationProperties
                };
            }
            {%- else %}
            return {
                body: data,
                subject: '{{ messageid }}',
                contentType: contentType
            };
            {%- endif %}
        });
        
        await this.sender.sendMessages(messages);
    }
    {% endfor %}
    
    /**
     * Close the producer
     */
    async close(): Promise<void> {
        await this.sender.close();
        await this.client.close();
    }
}
{% endfor %}
