{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import * as rhea from 'rhea';
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(root) %}
{%- if uses_cloudevents_message %}
import { CloudEvent } from 'cloudevents';
{%- endif %}
import { v4 as uuidv4 } from 'uuid';

{% for messagegroupid, messagegroup in messagegroups.items() -%}
{%- set groupname = messagegroupid | pascal -%}
{%- set class_name = (groupname | strip_namespace) + "Producer" %}

/**
 * Producer class to send messages in the `{{ messagegroupid }}` message group.
 */
export class {{ class_name }} {
    private connection: rhea.Connection;
    private sender: rhea.Sender;
    
    /**
     * Constructor
     * @param host The AMQP host
     * @param port The AMQP port
     * @param address The AMQP address (queue or topic)
     * @param username Optional username for authentication
     * @param password Optional password for authentication
     */
    constructor(
        host: string,
        port: number = 5672,
        address: string,
        username?: string,
        password?: string
    ) {
        const container = rhea.create_container();
        
        const connectionOptions: rhea.ConnectionOptions = {
            host: host,
            port: port
        };
        
        if (username && password) {
            connectionOptions.username = username;
            connectionOptions.password = password;
        }
        
        this.connection = container.connect(connectionOptions);
        this.sender = this.connection.open_sender({ target: { address: address } });
    }
    
    {% for messageid, message in messagegroup.messages.items() -%}
    {%- set messagename = messageid | pascal | strip_namespace %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    {%- set type_name = util.body_type(data_project_name, root, message) %}
    
    /**
     * Send the `{{ messagename }}` message
     {%- if message.description %}
     * {{ message.description }}
     {%- endif %}
     * @param data The message data object
     * @param contentType The content type of the message data
     * @returns Promise that resolves when the message is sent
     */
    async send{{ messagename }}(
        data: {{ type_name }},
        contentType: string = 'application/json'
    ): Promise<void> {
        return new Promise((resolve, reject) => {
            {%- if isCloudEvent %}
            const cloudEvent = new CloudEvent({
                type: '{{ messageid }}',
                source: '/producer',
                id: uuidv4(),
                data: data,
                datacontenttype: contentType
            });
            
            const message: rhea.Message = {
                body: cloudEvent.toJSON(),
                content_type: 'application/cloudevents+json'
            };
            {%- else %}
            const message: rhea.Message = {
                body: data,
                application_properties: {
                    subject: '{{ messageid }}'
                },
                content_type: contentType
            };
            {%- endif %}
            
            this.sender.send(message);
            resolve();
        });
    }
    
    /**
     * Send multiple `{{ messagename }}` messages
     * @param dataArray Array of message data objects
     * @param contentType The content type of the message data
     * @returns Promise that resolves when all messages are sent
     */
    async send{{ messagename }}Batch(
        dataArray: {{ type_name }}[],
        contentType: string = 'application/json'
    ): Promise<void> {
        for (const data of dataArray) {
            await this.send{{ messagename }}(data, contentType);
        }
    }
    {% endfor %}
    
    /**
     * Close the producer
     */
    async close(): Promise<void> {
        return new Promise((resolve) => {
            this.sender.close();
            this.connection.close();
            resolve();
        });
    }
}
{% endfor %}
