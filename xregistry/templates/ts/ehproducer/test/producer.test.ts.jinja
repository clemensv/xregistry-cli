{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import { EventHubProducerClient } from '@azure/event-hubs';
import { GenericContainer, StartedTestContainer } from 'testcontainers';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(root) %}

import { {% for messagegroupid, messagegroup in messagegroups.items() -%}{%- set class_name = (messagegroupid | pascal | strip_namespace) + "Producer" %}{{ class_name }}{% if not loop.last %}, {% endif %}{% endfor %} } from '../src';
{%- if uses_cloudevents_message %}
import { CloudEvent } from 'cloudevents';
{%- endif %}

// Import data types (need to compile data project first: cd ../{{ data_project_name }} && npm install && npm run build)
// NOTE: In real usage, the data project should be a proper npm package dependency
import * as {{ data_project_name }} from '../../{{ data_project_name }}/dist/index.js';

jest.setTimeout(120000);

{%- for messagegroupid, messagegroup in messagegroups.items() %}
{%- set pascal_group_name = messagegroupid | pascal %}
{%- set class_name = (pascal_group_name | strip_namespace) + "Producer" %}
{%- set test_class_name = (project_name | strip_dots | pascal) + (pascal_group_name | strip_dots) + "Tests" %}

describe('{{ test_class_name }}', () => {
    let azuriteContainer: StartedTestContainer;
    let eventhubsContainer: StartedTestContainer;
    let eventHubConnectionString: string;
    let configFilePath: string;
    
    beforeAll(async () => {
        // Create Event Hubs emulator config file
        const emulatorConfig = {
            "UserConfig": {
                "NamespaceConfig": [
                    {
                        "Type": "EventHub",
                        "Name": "emulatorNs1",
                        "Entities": [
                            {
                                "Name": "eh1",
                                "PartitionCount": "2",
                                "ConsumerGroups": [
                                    {
                                        "Name": "cg1"
                                    }
                                ]
                            }
                        ]
                    }
                ],
                "LoggingConfig": {
                    "Type": "File"
                }
            }
        };
        
        configFilePath = path.join(os.tmpdir(), `eh-config-${Date.now()}.json`);
        fs.writeFileSync(configFilePath, JSON.stringify(emulatorConfig));
        
        // Start Azurite for blob storage (needed for Event Hubs checkpointing)
        azuriteContainer = await new GenericContainer('mcr.microsoft.com/azure-storage/azurite:latest')
            .withCommand(['--skipApiVersionCheck'])
            .withExposedPorts(10000, 10001, 10002)
            .start();
        
        const azuriteHost = azuriteContainer.getHost();
        const azuriteBlobPort = azuriteContainer.getMappedPort(10000);
        
        // Start Event Hubs emulator
        // Note: Event Hubs emulator needs to connect to Azurite, so we use host network mode
        eventhubsContainer = await new GenericContainer('mcr.microsoft.com/azure-messaging/eventhubs-emulator:latest')
            .withBindMounts([{
                source: configFilePath,
                target: '/Eventhubs_Emulator/ConfigFiles/Config.json'
            }])
            .withExposedPorts(5672)
            .withEnvironment({
                'BLOB_SERVER': `${azuriteHost}`,
                'METADATA_SERVER': `${azuriteHost}`,
                'ACCEPT_EULA': 'Y'
            })
            .withStartupTimeout(120000)
            .start();
        
        const emulatorPort = eventhubsContainer.getMappedPort(5672);
        eventHubConnectionString = `Endpoint=sb://localhost:${emulatorPort};SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=SAS_KEY_VALUE;UseDevelopmentEmulator=true;EntityPath=eh1`;
        
        // Give Event Hubs emulator time to initialize
        await new Promise(resolve => setTimeout(resolve, 20000));
    }, 180000);
    
    afterAll(async () => {
        if (eventhubsContainer) {
            try {
                await eventhubsContainer.stop();
            } catch (e) {
                console.error('Error stopping Event Hubs container:', e);
            }
        }
        if (azuriteContainer) {
            try {
                await azuriteContainer.stop();
            } catch (e) {
                console.error('Error stopping Azurite container:', e);
            }
        }
        if (configFilePath && fs.existsSync(configFilePath)) {
            fs.unlinkSync(configFilePath);
        }
    });

    {%- set message_list = messagegroup.messages.items() | list %}
    {%- for messageid, message in message_list[:3] %}
    {%- set messagename = messageid | strip_namespace | pascal %}
    {%- set body_type = util.body_type(data_project_name, root, message) %}
    
    test('should send {{ messagename }} event', async () => {
        const producerClient = new EventHubProducerClient(eventHubConnectionString);
        const producer = new {{ class_name }}(producerClient);
        
        try {
            const testData = {} as {{ body_type }};
            await producer.send{{ messagename }}(testData);
            // Test passes if send succeeds without throwing
            expect(true).toBe(true);
        } finally {
            await producer.close();
        }
    }, 60000);
    
    test('should send {{ messagename }} batch', async () => {
        const producerClient = new EventHubProducerClient(eventHubConnectionString);
        const producer = new {{ class_name }}(producerClient);
        
        try {
            const testData = [
                {} as {{ body_type }},
                {} as {{ body_type }}
            ];
            await producer.send{{ messagename }}Batch(testData);
            // Test passes if send succeeds without throwing
            expect(true).toBe(true);
        } finally {
            await producer.close();
        }
    }, 60000);
    {%- endfor %}
});
{%- endfor %}
