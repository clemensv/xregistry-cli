{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import { EventHubProducerClient, EventData } from '@azure/event-hubs';
import { TokenCredential, DefaultAzureCredential } from '@azure/identity';
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(root) %}
{%- if uses_cloudevents_message %}
import { CloudEvent, HTTP } from 'cloudevents';
{%- endif %}
import { v4 as uuidv4 } from 'uuid';

{% for messagegroupid, messagegroup in messagegroups.items() -%}
{%- set groupname = messagegroupid | pascal -%}
{%- set class_name = (groupname | strip_namespace) + "Producer" %}

/**
 * Producer class to send events in the `{{ messagegroupid }}` message group.
 */
export class {{ class_name }} {
    private client: EventHubProducerClient;
    
    /**
     * Constructor
     * @param client The Azure Event Hubs producer client
     */
    constructor(client: EventHubProducerClient) {
        this.client = client;
    }
    
    {%- if root.endpoints %}
    {%- for endpointid, endpoint in root.endpoints.items() %}
    {%- if endpoint.usage == "producer" %}
    {%- set protocol = endpoint.protocol | lower %}
    {%- if protocol == "amqp" %}
    {%- set options = endpoint.protocoloptions %}
    {%- set endpoints = endpoint.endpoints %}
    
    /**
     * Create a new instance for the {{ endpointid }} endpoint
     * @param credential The Azure credential to use for authentication
     * @param fullyQualifiedNamespace The fully qualified namespace of the Event Hub
     * @param eventHubName The name of the Event Hub
     * @returns A new instance of {{ class_name }}
     */
    static createFor{{ endpointid | pascal | strip_namespace }}(
        credential?: TokenCredential,
        fullyQualifiedNamespace?: string,
        eventHubName?: string
    ): {{ class_name }} {
        const cred = credential || new DefaultAzureCredential();
        const ns = fullyQualifiedNamespace || {% if endpoints %}'{{ endpoints[0].uri }}'{% else %}''{% endif %};
        const hub = eventHubName || {% if options and 'node' in options %}'{{ options['node'] }}'{% else %}''{% endif %};
        
        if (!ns) {
            throw new Error('fullyQualifiedNamespace is required');
        }
        if (!hub) {
            throw new Error('eventHubName is required');
        }
        
        const client = new EventHubProducerClient(ns, hub, cred);
        return new {{ class_name }}(client);
    }
    {%- endif %}
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    
    {% for messageid, message in messagegroup.messages.items() -%}
    {%- set messagename = messageid | pascal | strip_namespace %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    {%- set type_name = util.body_type(data_project_name, root, message) %}
    
    /**
     * Send the `{{ messagename }}` event
     {%- if message.description %}
     * Event description: "{{ message.description }}"
     {%- endif %}
     * @param data The event data object
     * @param contentType The content type of the message data
     * @returns Promise that resolves when the event is sent
     */
    async send{{ messagename }}(
        data: {{ type_name }},
        contentType: string = 'application/json'
    ): Promise<void> {
        {%- if isCloudEvent %}
        const cloudEvent = new CloudEvent({
            type: '{{ messageid }}',
            source: '/producer',
            id: uuidv4(),
            data: data,
            datacontenttype: contentType
        });
        
        const eventData: EventData = {
            body: cloudEvent.toJSON(),
            contentType: 'application/cloudevents+json'
        };
        {%- else %}
        const eventData: EventData = {
            body: data,
            properties: {
                subject: '{{ messageid }}'
            }
        };
        
        if (contentType) {
            eventData.contentType = contentType;
        }
        {%- endif %}
        
        await this.client.sendBatch([eventData]);
    }
    
    /**
     * Send multiple `{{ messagename }}` events in a batch
     * @param dataArray Array of event data objects
     * @param contentType The content type of the message data
     * @returns Promise that resolves when all events are sent
     */
    async send{{ messagename }}Batch(
        dataArray: {{ type_name }}[],
        contentType: string = 'application/json'
    ): Promise<void> {
        const eventDataArray: EventData[] = dataArray.map(data => {
            {%- if isCloudEvent %}
            const cloudEvent = new CloudEvent({
                type: '{{ messageid }}',
                source: '/producer',
                id: uuidv4(),
                data: data,
                datacontenttype: contentType
            });
            
            return {
                body: cloudEvent.toJSON(),
                contentType: 'application/cloudevents+json'
            };
            {%- else %}
            const eventData: EventData = {
                body: data,
                properties: {
                    subject: '{{ messageid }}'
                }
            };
            
            if (contentType) {
                eventData.contentType = contentType;
            }
            
            return eventData;
            {%- endif %}
        });
        
        await this.client.sendBatch(eventDataArray);
    }
    {% endfor %}
    
    /**
     * Close the producer client
     */
    async close(): Promise<void> {
        await this.client.close();
    }
}
{% endfor %}
