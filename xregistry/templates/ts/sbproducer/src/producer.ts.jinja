{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import { ServiceBusClient, ServiceBusSender, ServiceBusMessage } from '@azure/service-bus';
import { TokenCredential, DefaultAzureCredential } from '@azure/identity';
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(root) %}
{%- if uses_cloudevents_message %}
import { CloudEvent, HTTP } from 'cloudevents';
{%- endif %}
import { v4 as uuidv4 } from 'uuid';

{% for messagegroupid, messagegroup in messagegroups.items() -%}
{%- set groupname = messagegroupid | pascal -%}
{%- set class_name = (groupname | strip_namespace) + "Producer" %}

/**
 * Producer class to send messages in the `{{ messagegroupid }}` message group.
 */
export class {{ class_name }} {
    private client: ServiceBusClient;
    private sender: ServiceBusSender;
    
    /**
     * Constructor for queue
     * @param client The Azure Service Bus client
     * @param queueName The queue name
     */
    constructor(client: ServiceBusClient, queueName: string);
    
    /**
     * Constructor for topic
     * @param client The Azure Service Bus client
     * @param topicName The topic name
     * @param isQueue Set to false for topic
     */
    constructor(client: ServiceBusClient, topicOrQueueName: string, isQueue?: boolean);
    
    constructor(client: ServiceBusClient, topicOrQueueName: string, isQueue: boolean = true) {
        this.client = client;
        this.sender = client.createSender(topicOrQueueName);
    }
    
    {%- if root.endpoints %}
    {%- for endpointid, endpoint in root.endpoints.items() %}
    {%- if endpoint.usage == "producer" %}
    {%- set protocol = endpoint.protocol | lower %}
    {%- if protocol == "amqp" %}
    {%- set options = endpoint.protocoloptions %}
    {%- set endpoints = endpoint.endpoints %}
    
    /**
     * Create a new instance for the {{ endpointid }} endpoint
     * @param credential The Azure credential to use for authentication
     * @param fullyQualifiedNamespace The fully qualified namespace
     * @param queueOrTopicName The queue or topic name
     * @returns A new instance of {{ class_name }}
     */
    static createFor{{ endpointid | pascal | strip_namespace }}(
        credential?: TokenCredential,
        fullyQualifiedNamespace?: string,
        queueOrTopicName?: string
    ): {{ class_name }} {
        const cred = credential || new DefaultAzureCredential();
        const ns = fullyQualifiedNamespace || {% if endpoints %}'{{ endpoints[0].uri }}'{% else %}''{% endif %};
        const name = queueOrTopicName || {% if options and 'node' in options %}'{{ options['node'] }}'{% else %}''{% endif %};
        
        if (!ns) {
            throw new Error('fullyQualifiedNamespace is required');
        }
        if (!name) {
            throw new Error('queueOrTopicName is required');
        }
        
        const client = new ServiceBusClient(ns, cred);
        return new {{ class_name }}(client, name);
    }
    {%- endif %}
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    
    {% for messageid, message in messagegroup.messages.items() -%}
    {%- set messagename = messageid | pascal | strip_namespace %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    {%- set type_name = util.body_type(data_project_name, root, message) %}
    
    /**
     * Send the `{{ messagename }}` message
     {%- if message.description %}
     * {{ message.description }}
     {%- endif %}
     * @param data The message data object
     * @param contentType The content type of the message data
     * @returns Promise that resolves when the message is sent
     */
    async send{{ messagename }}(
        data: {{ type_name }},
        contentType: string = 'application/json'
    ): Promise<void> {
        {%- if isCloudEvent %}
        const cloudEvent = new CloudEvent({
            type: '{{ messageid }}',
            source: '/producer',
            id: uuidv4(),
            data: data,
            datacontenttype: contentType
        });
        
        const message: ServiceBusMessage = {
            body: cloudEvent.toJSON(),
            contentType: 'application/cloudevents+json'
        };
        {%- else %}
        const message: ServiceBusMessage = {
            body: data,
            subject: '{{ messageid }}',
            contentType: contentType
        };
        {%- endif %}
        
        await this.sender.sendMessages(message);
    }
    
    /**
     * Send multiple `{{ messagename }}` messages in a batch
     * @param dataArray Array of message data objects
     * @param contentType The content type of the message data
     * @returns Promise that resolves when all messages are sent
     */
    async send{{ messagename }}Batch(
        dataArray: {{ type_name }}[],
        contentType: string = 'application/json'
    ): Promise<void> {
        const messages: ServiceBusMessage[] = dataArray.map(data => {
            {%- if isCloudEvent %}
            const cloudEvent = new CloudEvent({
                type: '{{ messageid }}',
                source: '/producer',
                id: uuidv4(),
                data: data,
                datacontenttype: contentType
            });
            
            return {
                body: cloudEvent.toJSON(),
                contentType: 'application/cloudevents+json'
            };
            {%- else %}
            return {
                body: data,
                subject: '{{ messageid }}',
                contentType: contentType
            };
            {%- endif %}
        });
        
        await this.sender.sendMessages(messages);
    }
    {% endfor %}
    
    /**
     * Close the producer
     */
    async close(): Promise<void> {
        await this.sender.close();
        await this.client.close();
    }
}
{% endfor %}
