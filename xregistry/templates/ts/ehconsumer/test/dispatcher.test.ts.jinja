{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import { EventHubConsumerClient, EventHubProducerClient, ReceivedEventData, EventData } from '@azure/event-hubs';
import { ContainerClient } from '@azure/storage-blob';
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(root) %}

import { EventHubsProcessor, {% for messagegroupid, messagegroup in messagegroups.items() -%}{%- set class_name = (messagegroupid | pascal | strip_namespace) + "EventDispatcher" %}{{ class_name }}{% if not loop.last %}, {% endif %}{% endfor %} } from '../src';
{%- if uses_cloudevents_message %}
import { CloudEvent } from 'cloudevents';
{%- endif %}

// Import data types
import * as {{ data_project_name }} from '../../{{ data_project_name }}/dist/index.js';

// Simple mock for Azure Event Hubs Emulator
const EVENTHUB_CONNECTION_STRING = process.env.EVENTHUB_CONNECTION_STRING || 
    'Endpoint=sb://localhost;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=SAS_KEY_VALUE;UseDevelopmentEmulator=true;EntityPath=eh1';
const EVENTHUB_NAME = 'eh1';
const CONSUMER_GROUP = '$Default';
const BLOB_STORAGE_CONNECTION_STRING = process.env.BLOB_STORAGE_CONNECTION_STRING || 
    'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;';
const BLOB_CONTAINER_NAME = 'eventhub-checkpoints';

jest.setTimeout(60000);

{%- for messagegroupid, messagegroup in messagegroups.items() %}
{%- set pascal_group_name = messagegroupid | pascal %}
{%- set class_name = (pascal_group_name | strip_namespace) + "EventDispatcher" %}
{%- set test_class_name = (project_name | strip_dots | pascal) + (pascal_group_name | strip_dots) + "Tests" %}

describe('{{ test_class_name }}', () => {
    let producerClient: EventHubProducerClient;
    let consumerClient: EventHubConsumerClient;
    
    beforeAll(async () => {
        producerClient = new EventHubProducerClient(EVENTHUB_CONNECTION_STRING, EVENTHUB_NAME);
        consumerClient = new EventHubConsumerClient(
            CONSUMER_GROUP,
            EVENTHUB_CONNECTION_STRING,
            EVENTHUB_NAME
        );
    });
    
    afterAll(async () => {
        await producerClient.close();
        await consumerClient.close();
    });
    
    {%- set message_list = messagegroup.messages.items() | list %}
    {%- for messageid, message in message_list[:3] %}
    {%- set messagename = messageid | strip_namespace | pascal %}
    {%- set message_body_type = util.body_type(data_project_name, root, message) %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    
    test('should dispatch {{ messagename }} event', async () => {
        const dispatcher = new {{ class_name }}();
        const processor = new EventHubsProcessor(consumerClient);
        
        let messageReceived = false;
        let receivedData: {{ message_body_type }} | null = null;
        
        dispatcher.{{ messagename }}Handler = async (eventData: ReceivedEventData{% if isCloudEvent %}, cloudEvent: CloudEvent{% endif %}, data: {{ message_body_type }}) => {
            messageReceived = true;
            receivedData = data;
        };
        
        processor.processEvent = async (eventData: ReceivedEventData) => {
            await dispatcher.processEvent(eventData);
        };
        
        // Start processor first (matches C# pattern)
        await processor.start(CONSUMER_GROUP);
        
        // Send test event - use empty object with type assertion (like ehproducer tests)
        const testData = {} as {{ message_body_type }};
        
        {%- if isCloudEvent %}
        // Send CloudEvent formatted message
        const eventData = new EventData(JSON.stringify(testData));
        eventData.contentType = 'application/json';
        eventData.properties = {
            'cloudEvents_type': '{{ messageid }}',
            'cloudEvents_specversion': '1.0',
            'cloudEvents_source': '/test',
            'cloudEvents_id': Date.now().toString()
        };
        {%- else %}
        // Send plain AMQP message
        const eventData = new EventData(JSON.stringify(testData));
        eventData.contentType = 'application/json';
        eventData.properties = {
            'subject': '{{ messageid }}'
        };
        {%- endif %}
        
        await producerClient.sendBatch([eventData]);
        
        // Wait for message to be processed (10s timeout like C#)
        const startTime = Date.now();
        while (!messageReceived && Date.now() - startTime < 10000) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        await processor.stop();
        
        // Verify message was received
        expect(messageReceived).toBe(true);
        expect(receivedData).not.toBeNull();
    });
    {%- endfor %}
});
{%- endfor %}
