{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
{%- set data_module_name = data_project_name | strip_invalid_identifier_characters %}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import * as rhea from 'rhea';
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(root) %}
{%- if uses_cloudevents_message %}
import { CloudEvent, HTTP } from 'cloudevents';
{%- endif %}

// Import data types (need to compile data project first: cd ../{{ data_project_name }} && npm install && npm run build)
// NOTE: In real usage, the data project should be a proper npm package dependency
import * as {{ data_module_name }} from '../../{{ data_project_name }}/dist/index.js';

{% for messagegroupid, messagegroup in messagegroups.items() -%}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(messagegroup) %}
{%- set uses_amqp_message = true %}
{%- set groupname = messagegroupid | pascal -%}
{%- set class_name = (groupname | strip_namespace) + "EventConsumer" %}

/**
 * Event consumer for the {{ messagegroupid }} message group
 */
export class {{ class_name }} {
    {%- for messageid, message in messagegroup.messages.items() %}
    {%- set messagename = messageid | strip_dots | pascal %}
    {%- set message_body_type = util.body_type(data_project_name, root, message) %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    
    /**
     * Handler for {{ messagename }} messages
     {%- if message.description %}
     * {{ message.description }}
     {%- endif %}
     */
    public {{ messagename }}Handler?: ({% if isCloudEvent %}cloudEvent: CloudEvent, {% else %}message: rhea.Message, {% endif %}data: {{ message_body_type }}) => Promise<void>;
    {%- endfor %}
    
    {%- if uses_amqp_message %}
    /**
     * Handler for unhandled AMQP messages
     */
    public unhandledMessageHandler?: (message: rhea.Message) => Promise<void>;
    {%- endif %}
    
    {%- if uses_cloudevents_message %}
    /**
     * Handler for unhandled CloudEvents
     */
    public unhandledEventHandler?: (cloudEvent: CloudEvent) => Promise<void>;
    {%- endif %}
    
    /**
     * Process an AMQP message
     * @param message The AMQP message
     */
    async processMessage(message: rhea.Message): Promise<void> {
        {%- if uses_cloudevents_message %}
        if (this.isCloudEvent(message)) {
            const cloudEvent = this.cloudEventFromMessage(message);
            await this.dispatchCloudEvent(cloudEvent);
            return;
        }
        {%- endif %}
        
        await this.dispatchMessage(message);
    }
    
    {%- if uses_cloudevents_message %}
    
    /**
     * Check if an AMQP message is a CloudEvent
     */
    private isCloudEvent(message: rhea.Message): boolean {
        const contentType = message.content_type;
        if (contentType && (contentType.startsWith('application/cloudevents+json') || 
                           contentType.startsWith('application/cloudevents'))) {
            return true;
        }
        
        // Check for binary mode CloudEvent
        if (message.application_properties && 
            message.application_properties['cloudEvents:specversion']) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Convert an AMQP message to a CloudEvent
     */
    private cloudEventFromMessage(message: rhea.Message): CloudEvent {
        const contentType = message.content_type;
        
        // Structured mode
        if (contentType && contentType.startsWith('application/cloudevents+json')) {
            const body = message.body;
            if (typeof body === 'string') {
                return HTTP.toEvent({ body, headers: {} });
            } else if (Buffer.isBuffer(body)) {
                return HTTP.toEvent({ body: body.toString(), headers: {} });
            } else if (typeof body === 'object') {
                return new CloudEvent(body);
            }
        }
        
        // Binary mode
        const props = message.application_properties || {};
        return new CloudEvent({
            specversion: (props['cloudEvents:specversion'] || props['cloudEvents_specversion']) as string,
            type: (props['cloudEvents:type'] || props['cloudEvents_type']) as string,
            source: (props['cloudEvents:source'] || props['cloudEvents_source']) as string,
            id: (props['cloudEvents:id'] || props['cloudEvents_id']) as string,
            time: props['cloudEvents:time'] || props['cloudEvents_time'],
            datacontenttype: message.content_type || 'application/json',
            data: message.body
        });
    }
    
    /**
     * Dispatch a CloudEvent message
     */
    private async dispatchCloudEvent(cloudEvent: CloudEvent): Promise<void> {
        const cloudEventType = cloudEvent.type;
        
        switch (cloudEventType) {
            {% for messageid, message in messagegroup.messages.items() -%}
            {%- set messagename = messageid | strip_dots | pascal %}
            {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
            {%- set message_body_type = util.body_type(data_project_name, root, message) %}
            {%- if isCloudEvent %}
            case '{{ messageid }}':
                if (this.{{ messagename }}Handler) {
                    const data = cloudEvent.data as unknown as {{ message_body_type }};
                    await this.{{ messagename }}Handler(cloudEvent, data);
                    return;
                }
                break;
            {%- endif %}
            {% endfor %}
            default:
                if (this.unhandledEventHandler) {
                    await this.unhandledEventHandler(cloudEvent);
                }
                break;
        }
    }
    {%- endif %}
    
    {%- if uses_amqp_message %}
    /**
     * Dispatch a plain AMQP message
     */
    private async dispatchMessage(message: rhea.Message): Promise<void> {
        const messageSubject = message.application_properties?.['subject'];
        
        switch (messageSubject) {
            {% for messageid, message in messagegroup.messages.items() if not cloudEvents.isCloudEvent(message) -%}
            {%- set messagename = messageid | strip_dots | pascal %}
            {%- set message_body_type = util.body_type(data_project_name, root, message) %}
            case '{{ messageid }}':
                if (this.{{ messagename }}Handler) {
                    const data = message.body as {{ message_body_type }};
                    await this.{{ messagename }}Handler(message, data);
                    return;
                }
                break;
            {% endfor %}
            default:
                if (this.unhandledMessageHandler) {
                    await this.unhandledMessageHandler(message);
                }
                break;
        }
    }
    {%- endif %}
}
{% endfor %}
