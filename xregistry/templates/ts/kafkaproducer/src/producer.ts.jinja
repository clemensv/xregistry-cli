{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = (root | exists("envelope","CloudEvents/1.0")) %}
{%- set uses_kafka_message = (root | exists( "protocol", "kafka")) %}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import { Producer, ProducerRecord, Message } from 'kafkajs';
import { CloudEvent } from 'cloudevents';
import { v4 as uuidv4 } from 'uuid';

// Import data types (need to compile data project first: cd ../{{ data_project_name }} && npm install && npm run build)
// NOTE: In real usage, the data project should be a proper npm package dependency
import * as {{ data_project_name }} from '../../{{ data_project_name }}/dist/index.js';

{% for messagegroupid, messagegroup in messagegroups.items() -%}
{%- set groupname = messagegroupid | pascal -%}
{%- set class_name = (groupname | strip_namespace) + "Producer" %}

/**
 * Producer class to send events in the `{{ messagegroupid }}` message group.
 */
export class {{ class_name }} {
    private producer: Producer;
    
    /**
     * Create a new {{ class_name }}
     * @param producer The KafkaJS producer instance
     */
    constructor(producer: Producer) {
        this.producer = producer;
    }
    
    {%- if root.endpoints -%}
    {%- for endpointid, endpoint in root.endpoints.items() -%}
    {%- if endpoint.usage == "producer" -%}
    {%- set protocol = endpoint.protocol | lower -%}
    {%- if protocol == "kafka" -%}
    {%- set endpoints = endpoint.endpoints %}
    
    /**
     * Create a new producer for the {{ endpointid }} endpoint
     * @param kafka The Kafka instance
     * @returns A new {{ class_name }} instance
     */
    static async createFor{{ endpointid | pascal | strip_namespace }}(kafka: any): Promise<{{ class_name }}> {
        const producer = kafka.producer();
        await producer.connect();
        return new {{ class_name }}(producer);
    }
    {%- endif -%}
    {%- endif -%}
    {%- endfor -%}
    {% endif %}

    {% for messageid, message in messagegroup.messages.items() -%}
    {%- set messagename = messageid | pascal %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    {%- set isKafka = not isCloudEvent and (message | exists("protocol", "kafka")) %}
    {%- set type_name = util.body_type(data_project_name, root, message) -%}
    {%- if message.description %}
    /**
     * {{ message.description }}
     */
    {%- endif %}
    
    /**
     * Send a {{ messagename }} event
     * @param data The event data
     {%- if isCloudEvent %}
     * @param source The CloudEvent source (defaults to generated)
     {%- endif %}
     * @param contentType The content type (defaults to application/json)
     * @returns Promise that resolves when the message is sent
     */
    async send{{ messagename | strip_namespace }}(
        data: {{ type_name }},
        {%- if isCloudEvent %}
        source?: string,
        {%- endif %}
        contentType: string = 'application/json'
    ): Promise<void> {
        const message = this.create{{ messagename | strip_namespace }}Message(
            data,
            {%- if isCloudEvent %}
            source,
            {%- endif %}
            contentType
        );
        
        await this.producer.send({
            topic: '{{ messagename }}',
            messages: [message]
        });
    }
    
    /**
     * Send a batch of {{ messagename }} events
     * @param dataArray Array of event data
     {%- if isCloudEvent %}
     * @param source The CloudEvent source (defaults to generated)
     {%- endif %}
     * @param contentType The content type (defaults to application/json)
     * @returns Promise that resolves when all messages are sent
     */
    async send{{ messagename | strip_namespace }}Batch(
        dataArray: {{ type_name }}[],
        {%- if isCloudEvent %}
        source?: string,
        {%- endif %}
        contentType: string = 'application/json'
    ): Promise<void> {
        const messages = dataArray.map(data => 
            this.create{{ messagename | strip_namespace }}Message(
                data,
                {%- if isCloudEvent %}
                source,
                {%- endif %}
                contentType
            )
        );
        
        await this.producer.send({
            topic: '{{ messagename }}',
            messages
        });
    }
    
    /**
     * Create a Kafka message for {{ messagename }}
     */
    private create{{ messagename | strip_namespace }}Message(
        data: {{ type_name }},
        {%- if isCloudEvent %}
        source?: string,
        {%- endif %}
        contentType: string = 'application/json'
    ): Message {
        {%- if isCloudEvent %}
        const cloudEvent = new CloudEvent({
            type: '{{ messageid }}',
            source: source || `{{ messagegroupid }}/producer`,
            id: uuidv4(),
            datacontenttype: contentType,
            data: data
        });
        
        // Use structured mode
        return {
            headers: {
                'content-type': 'application/cloudevents+json'
            },
            value: Buffer.from(JSON.stringify(cloudEvent))
        };
        {%- else %}
        return {
            headers: {
                'subject': '{{ messageid }}',
                'content-type': contentType
            },
            value: Buffer.from(JSON.stringify(data))
        };
        {%- endif %}
    }
    {% endfor %}
    
    /**
     * Disconnect the producer
     */
    async disconnect(): Promise<void> {
        await this.producer.disconnect();
    }
}

{% endfor -%}
