{%- import "util.jinja.include" as util -%}
{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "amqp.jinja.include" as amqp -%}
{{ util.CommonFileHeader() }}

package {{ project_name | lower | replace('-', '_') }};

import org.apache.qpid.proton.Proton;
import org.apache.qpid.proton.reactor.Reactor;
import org.apache.qpid.proton.reactor.ReactorOptions;
import org.apache.qpid.proton.message.Message;
import org.apache.qpid.proton.amqp.messaging.Data;
import org.apache.qpid.proton.amqp.Binary;
import org.apache.qpid.proton.engine.Connection;
import org.apache.qpid.proton.engine.Sender;
import org.apache.qpid.proton.reactor.FlowController;
import org.apache.qpid.proton.reactor.Handshaker;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

import java.net.URI;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

{{ util.EndpointCredentialClasses() }}

/**
 * AMQP 1.0 producer using Apache Qpid Proton-J
 */
class AmqpProducer {
    private static final Logger logger = LogManager.getLogger(AmqpProducer.class);
    private final EndpointCredential credential;
    private final List<URI> endpoints;
    private final String node;
    private final Map<URI, ConnectionInfo> connectionCache = new ConcurrentHashMap<>();
    private Reactor reactor;
    
    private static class ConnectionInfo {
        final Connection connection;
        final Sender sender;
        
        ConnectionInfo(Connection connection, Sender sender) {
            this.connection = connection;
            this.sender = sender;
        }
    }
    
    public AmqpProducer(EndpointCredential credential, Map<String, String> options, List<URI> endpoints) {
        this.credential = credential;
        this.endpoints = endpoints;
        this.node = options.getOrDefault("node", null);
        
        try {
            ReactorOptions reactorOptions = new ReactorOptions();
            this.reactor = Proton.reactor(reactorOptions);
        } catch (Exception ex) {
            logger.error("Failed to initialize AMQP reactor: " + ex.getMessage(), ex);
            throw new RuntimeException("Failed to initialize AMQP reactor", ex);
        }
    }
    
    /**
     * Send a Proton-J message to all configured endpoints
     */
    public void send(Message message) throws Exception {
        Exception lastException = null;
        
        for (URI endpoint : endpoints) {
            try {
                ConnectionInfo connInfo = getOrCreateConnection(endpoint);
                
                CompletableFuture<Void> sendFuture = new CompletableFuture<>();
                
                // Send message asynchronously
                reactor.schedule(() -> {
                    try {
                        byte[] encoded = new byte[1024];
                        int length = message.encode(encoded, 0, encoded.length);
                        connInfo.sender.send(encoded, 0, length);
                        sendFuture.complete(null);
                    } catch (Exception ex) {
                        sendFuture.completeExceptionally(ex);
                    }
                }, 0);
                
                // Wait for send to complete with timeout
                try {
                    sendFuture.get(30, TimeUnit.SECONDS);
                } catch (TimeoutException | InterruptedException | ExecutionException ex) {
                    logger.error("Error sending message to endpoint " + endpoint + ": " + ex.getMessage(), ex);
                    endpoints.remove(endpoint);
                    connectionCache.remove(endpoint);
                    lastException = ex instanceof ExecutionException ? 
                        (Exception)ex.getCause() : (Exception)ex;
                }
            } catch (Exception ex) {
                logger.error("Error sending to endpoint " + endpoint + ": " + ex.getMessage(), ex);
                lastException = ex;
            }
        }
        
        if (lastException != null) {
            throw lastException;
        }
    }
    
    /**
     * Gets or creates a connection to the specified endpoint
     */
    private ConnectionInfo getOrCreateConnection(URI endpoint) throws Exception {
        return connectionCache.computeIfAbsent(endpoint, ep -> {
            try {
                String host = ep.getHost();
                int port = ep.getPort() == -1 ? 
                    (ep.getScheme().equalsIgnoreCase("amqps") ? 5671 : 5672) : 
                    ep.getPort();
                String path = node != null ? node : ep.getPath();
                
                Connection connection = reactor.connection();
                connection.setHostname(host + ":" + port);
                connection.setContainer("amqp-producer-" + System.currentTimeMillis());
                
                // Configure authentication
                if (credential instanceof PlainEndpointCredential) {
                    PlainEndpointCredential plain = (PlainEndpointCredential) credential;
                    connection.setUser(plain.getClientId());
                    connection.setPassword(plain.getClientSecret());
                } else if (credential instanceof TokenEndpointCredential) {
                    // For token auth, we'll use CBS (Claims-Based Security)
                    // This requires additional setup after connection is established
                    connection.setUser(null);
                }
                
                connection.open();
                
                org.apache.qpid.proton.engine.Session session = connection.session();
                session.open();
                
                Sender sender = session.sender("sender-link");
                if (path != null && !path.isEmpty()) {
                    sender.setTarget(Proton.terminus());
                    sender.getTarget().setAddress(path);
                }
                sender.open();
                
                // Handle token authentication via CBS if needed
                if (credential instanceof TokenEndpointCredential) {
                    sendCbsToken(connection, (TokenEndpointCredential) credential, host, path);
                }
                
                return new ConnectionInfo(connection, sender);
            } catch (Exception ex) {
                logger.error("Failed to establish connection to " + endpoint + ": " + ex.getMessage(), ex);
                throw new RuntimeException("Failed to connect to endpoint", ex);
            }
        });
    }
    
    /**
     * Send CBS token for authentication
     */
    private void sendCbsToken(Connection connection, TokenEndpointCredential tokenCred, String host, String path) {
        try {
            String token = tokenCred.getToken();
            
            org.apache.qpid.proton.engine.Session cbsSession = connection.session();
            cbsSession.open();
            
            Sender cbsSender = cbsSession.sender("cbs-sender");
            cbsSender.setTarget(Proton.terminus());
            cbsSender.getTarget().setAddress("$cbs");
            cbsSender.open();
            
            Message cbsMessage = Proton.message();
            cbsMessage.setBody(new Data(new Binary(token.getBytes())));
            cbsMessage.setMessageId(java.util.UUID.randomUUID().toString());
            cbsMessage.setApplicationProperty("operation", "put-token");
            cbsMessage.setApplicationProperty("type", "amqp:jwt");
            cbsMessage.setApplicationProperty("name", "amqp://" + host + "/" + path);
            
            byte[] encoded = new byte[1024];
            int length = cbsMessage.encode(encoded, 0, encoded.length);
            cbsSender.send(encoded, 0, length);
            
            cbsSender.close();
            cbsSession.close();
        } catch (Exception ex) {
            logger.warn("Failed to send CBS token: " + ex.getMessage(), ex);
        }
    }
    
    /**
     * Close all connections and shut down the reactor
     */
    public void close() {
        connectionCache.values().forEach(connInfo -> {
            try {
                if (connInfo.sender != null) {
                    connInfo.sender.close();
                }
                if (connInfo.connection != null) {
                    connInfo.connection.close();
                }
            } catch (Exception ex) {
                logger.warn("Error closing connection: " + ex.getMessage(), ex);
            }
        });
        connectionCache.clear();
        
        if (reactor != null) {
            try {
                reactor.stop();
                reactor.free();
            } catch (Exception ex) {
                logger.warn("Error stopping reactor: " + ex.getMessage(), ex);
            }
        }
    }
}
