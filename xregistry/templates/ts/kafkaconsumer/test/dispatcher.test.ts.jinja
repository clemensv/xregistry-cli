{%- import "cloudevents.jinja.include" as cloudEvents %}
{%- import "util.jinja.include" as util -%}
{%- set messagegroups = root.messagegroups %}
{%- set uses_ce_message = (root | exists("envelope","CloudEvents/1.0")) %}
{%- set uses_plain_kafka_message = (root | exists( "protocol", "kafka" )) %}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import { Kafka, Producer, Consumer, logLevel } from 'kafkajs';
import { GenericContainer, StartedTestContainer, Wait } from 'testcontainers';
{%- if uses_ce_message %}
import { CloudEvent } from 'cloudevents';
{%- endif %}
import { KafkaProcessor } from '../src/tools';
{% for messagegroupid, messagegroup in messagegroups.items() -%}
{%- set pascal_group_name = messagegroupid | pascal %}
{%- set class_name = ( pascal_group_name | strip_namespace ) + "EventDispatcher" %}
import { {{ class_name }} } from '../src/dispatcher';
{%- endfor %}

describe('{{ project_name }} Kafka Consumer Tests', () => {
    let kafkaContainer: StartedTestContainer;
    let kafka: Kafka;
    let producer: Producer;
    let consumer: Consumer;
    let bootstrapServers: string;
    const topicName = 'test-topic';
    
    beforeAll(async () => {
        // Start Kafka container
        kafkaContainer = await new GenericContainer('confluentinc/cp-kafka:7.5.0')
            .withEnvironment({
                'KAFKA_NODE_ID': '1',
                'KAFKA_LISTENER_SECURITY_PROTOCOL_MAP': 'CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT',
                'KAFKA_ADVERTISED_LISTENERS': 'PLAINTEXT://localhost:9092,PLAINTEXT_HOST://localhost:29092',
                'KAFKA_LISTENERS': 'PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093,PLAINTEXT_HOST://0.0.0.0:29092',
                'KAFKA_INTER_BROKER_LISTENER_NAME': 'PLAINTEXT',
                'KAFKA_CONTROLLER_LISTENER_NAMES': 'CONTROLLER',
                'KAFKA_CONTROLLER_QUORUM_VOTERS': '1@localhost:9093',
                'KAFKA_PROCESS_ROLES': 'broker,controller',
                'KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR': '1',
                'KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR': '1',
                'KAFKA_TRANSACTION_STATE_LOG_MIN_ISR': '1',
                'KAFKA_LOG_DIRS': '/tmp/kraft-combined-logs',
                'CLUSTER_ID': 'MkU3OEVBNTcwNTJENDM2Qk'
            })
            .withExposedPorts(9092, 29092)
            .withWaitStrategy(Wait.forLogMessage('.*Kafka Server started.*'))
            .withStartupTimeout(120000)
            .start();
            
        const host = kafkaContainer.getHost();
        const port = kafkaContainer.getMappedPort(9092);
        bootstrapServers = `${host}:${port}`;
        
        kafka = new Kafka({
            clientId: 'test-client',
            brokers: [bootstrapServers],
            logLevel: logLevel.ERROR
        });
        
        // Create admin client to create topic
        const admin = kafka.admin();
        await admin.connect();
        await admin.createTopics({
            topics: [{ topic: topicName, numPartitions: 1, replicationFactor: 1 }]
        });
        await admin.disconnect();
        
        // Create producer
        producer = kafka.producer();
        await producer.connect();
    });
    
    afterAll(async () => {
        if (producer) {
            await producer.disconnect();
        }
        if (consumer) {
            await consumer.disconnect();
        }
        if (kafkaContainer) {
            await kafkaContainer.stop();
        }
    });
    
    beforeEach(async () => {
        // Create a new consumer with unique group ID for each test
        const groupId = `test-group-${Date.now()}-${Math.random()}`;
        consumer = kafka.consumer({ groupId });
        await consumer.connect();
    });
    
    afterEach(async () => {
        if (consumer) {
            await consumer.disconnect();
        }
    });
    
    {% for messagegroupid, messagegroup in messagegroups.items() -%}
    {%- set uses_cloudevents_message = (messagegroup | exists("envelope","CloudEvents/1.0")) %}
    {%- set pascal_group_name = messagegroupid | pascal %}
    {%- set class_name = ( pascal_group_name | strip_namespace ) + "EventDispatcher" %}
    
    describe('{{ pascal_group_name }} Message Group', () => {
        {% for messageid, message in messagegroup.messages.items() -%}
        {%- set messagename = messageid | strip_namespace | pascal -%}
        {%- set message_body_type = util.body_type(data_project_name, root, message) -%}
        {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
        
        test('should receive and dispatch {{ messagename }} event', async () => {
            const dispatcher = new {{ class_name }}();
            const processor = new KafkaProcessor(consumer, topicName);
            
            const receivedMessages: any[] = [];
            
            dispatcher.{{ messagename }}Handler = async (message, {% if isCloudEvent %}cloudEvent, {% endif %}data) => {
                receivedMessages.push({ message, {% if isCloudEvent %}cloudEvent, {% endif %}data });
            };
            
            processor.processMessage = async (payload) => {
                await dispatcher.processMessage(payload);
            };
            
            // Start consuming
            const processorPromise = processor.start();
            
            // Wait a bit for consumer to be ready
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Send test message
            {%- if isCloudEvent %}
            const testData = { test: 'data' };
            const cloudEvent = new CloudEvent({
                type: '{{ messageid }}',
                source: 'test/source',
                data: testData
            });
            
            await producer.send({
                topic: topicName,
                messages: [{
                    headers: {
                        'content-type': 'application/cloudevents+json'
                    },
                    value: JSON.stringify(cloudEvent)
                }]
            });
            {%- else %}
            const testData = { test: 'data' };
            
            await producer.send({
                topic: topicName,
                messages: [{
                    headers: {
                        'subject': '{{ messageid }}',
                        'content-type': 'application/json'
                    },
                    value: JSON.stringify(testData)
                }]
            });
            {%- endif %}
            
            // Wait for message to be processed
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Stop processor
            await processor.stop();
            
            // Verify
            expect(receivedMessages.length).toBeGreaterThan(0);
            {%- if isCloudEvent %}
            expect(receivedMessages[0].cloudEvent.type).toBe('{{ messageid }}');
            {%- endif %}
            expect(receivedMessages[0].data).toMatchObject({ test: 'data' });
        }, 30000);
        {% endfor %}
    });
    {% endfor %}
});
