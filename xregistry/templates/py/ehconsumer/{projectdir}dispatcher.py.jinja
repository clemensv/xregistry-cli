
"""
Dispatcher module for processing events from Azure Event Hubs.
"""

{% import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "eventhubs.jinja.include" as eventhub -%}
{%- import "util.include.jinja" as util -%}
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = (root | exists( "format", "cloudevents" )) %}
{%- set uses_plain_amqp_message = (root | exists( "binding", "amqp" )) %}
{%- set uses_amqp_endpoint = (root | exists( "protocol", "amqp" )) %}
{%- set function_name = project_name | pascal -%}
import asyncio
from typing import Awaitable, Callable
from azure.eventhub import EventData
from azure.eventhub.aio import EventHubConsumerClient
from azure.storage.blob.aio import BlobServiceClient
from cloudevents.http import from_http, CloudEvent

{%- set messagegroups = root.messagegroups %}
{%- set imports = [] %}
{%- for messagegroup_key in messagegroups.keys() -%}
{%- set messagegroup = messagegroups[messagegroup_key] -%}
{%- for id in messagegroup.messages -%}
{%- set definition = messagegroup.messages[id] %}
{%- set type_name = util.DeclareDataType( '', root, definition ) %}
{%- if type_name != "object" %}
{%- set import_statement = "from " + (type_name | lower) + " import " + type_name | strip_namespace %}
{%- if import_statement not in imports %}
{%- set _ = imports.append(import_statement) %}
{{ import_statement }}
{%- endif %}
{%- endif %}
{%- endfor %}
{%- endfor %}

class DispatcherBase:
    """
    Base class for dispatching events. Handles CloudEvent detection and conversion.
    """
    AMQP_CLOUDEVENT_PREFIX1 = "cloudEvents_"
    AMQP_CLOUDEVENT_PREFIX2 = "cloudEvents:"

    @staticmethod
    def _get_cloud_event_attribute(event_data, key):
        """
        Retrieves a CloudEvent attribute from the event data.

        Args:
            event_data: The event data containing properties.
            key: The attribute key to retrieve.

        Returns:
            The attribute value or None if not found.
        """
        return event_data.properties.get(DispatcherBase.AMQP_CLOUDEVENT_PREFIX1 + key) or event_data.properties.get(DispatcherBase.AMQP_CLOUDEVENT_PREFIX2 + key)

    @staticmethod
    def _is_cloud_event(event_data):
        """
        Checks if the event data is a CloudEvent.

        Args:
            event_data: The event data to check.

        Returns:
            True if the event data is a CloudEvent, False otherwise.
        """
        return event_data.content_type and 'application/cloudevents' in event_data.content_type or \
               any(key.startswith(DispatcherBase.AMQP_CLOUDEVENT_PREFIX1) or key.startswith(DispatcherBase.AMQP_CLOUDEVENT_PREFIX2) for key in event_data.properties)

    @staticmethod
    def _cloud_event_from_event_data(event_data):
        """
        Converts event data to a CloudEvent.

        Args:
            event_data: The event data to convert.

        Returns:
            A CloudEvent object.
        """
        headers = {
            "Content-Type": event_data.content_type
        }
        for key, value in event_data.properties.items():
            if key.startswith(DispatcherBase.AMQP_CLOUDEVENT_PREFIX1) or key.startswith(DispatcherBase.AMQP_CLOUDEVENT_PREFIX2):
                headers[key[len(DispatcherBase.AMQP_CLOUDEVENT_PREFIX1):]] = value
        return from_http(event_data.body_as_str(), headers)

{% for messagegroup_key, messagegroup in messagegroups.items() %}
{%- set uses_cloudevents_message = (messagegroup | exists( "format", "cloudevents" )) %}
{%- set uses_plain_amqp_message = (messagegroup | existswithout( "binding", "amqp", "format", "cloudevents" )) %}
{%- set pascalGroupName = messagegroup.id | pascal %}
{%- set class_name = ( pascalGroupName | strip_namespace )+"EventDispatcher" %}

class {{ class_name }}(DispatcherBase):
    """
    Dispatcher for {{ pascalGroupName }} events.
    """
    {%- if (messagegroup | exists( "format", "cloudevents" )) %}

    {%- endif %}
    {%- for id, message in messagegroup.messages.items() %}
    {%- set definitionName = message.id | strip_namespace %}
    {%- if message.schemaurl or message.schema %}
    {%- set dataType = (message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat) %}
    {%- else %}
    {%- set dataType = "object" %}
    {%- endif %}
    {%- if message.description %}
    # {{ message.description }}
    {%- endif %}
    {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) %}
    {%- set isAmqp = (message | existswithout( "binding", "amqp", "format", "cloudevents" )) %}
    {{ definitionName | strip_namespace }}_async: Callable[[EventData, CloudEvent, {{ dataType | strip_namespace }}], Awaitable[None]] = lambda event, cloud_event,  {{ dataType | strip_namespace }}: None

    {%- endfor %}

    async def process_event(self, event):
        """
        Processes an incoming event.

        Args:
            event: The event data to process.
        """
        if self._is_cloud_event(event):
            cloud_event = self._cloud_event_from_event_data(event)
            await self._dispatch_cloud_event(event, cloud_event)
            return
        if event:
            await self._dispatch_event_data(event)

    async def dispatch_cloud_event(self, event, cloud_event):
        """
        Dispatches a CloudEvent to the appropriate handler.

        Args:
            event: The original event data.
            cloud_event: The CloudEvent object.
        """
        cloud_event_type = cloud_event['type']
        switcher = {
            {%- for id, message in messagegroup.messages.items() %}
            {%- set definitionName = message.id %}
            {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) %}
            {%- if message.schemaurl or message.schema %}
            {%- set dataType = (message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat) %}
            {%- else %}
            {%- set dataType = "object" %}
            {%- endif %}
            "{{ message.id }}": lambda: self.{{ definitionName | strip_namespace }}_async(event, cloud_event,
            {%- if dataType != "object" %}
                {{ dataType | strip_namespace }}.from_data(cloud_event.data, cloud_event["datacontenttype"])
            {%- else %}
            cloud_event.data
            {%- endif %})
            {%- if not loop.last %}
            ,
            {%- endif %}
            {%- endfor %}
        }
        func = switcher.get(cloud_event_type, lambda: None)
        if func:
            await func()

    async def dispatch_event_data(self, event):
        """
        Dispatches an AMQP event to the appropriate handler.

        Args:
            event: The event data to dispatch.
        """
        message_subject = event.raw_amqp_message.properties.subject
        switcher = {
            {%- for id, message in messagegroup.messages.items() if ((message | exists("binding", "amqp" )) and not (message | exists("format", "cloudevents" ))) %}
            {%- set definitionName = message.id %}
            {%- set isCloudEvent = (message | exists( "format", "cloudevents" )) %}
            {%- if message.schemaurl or message.schema %}
            {%- set dataType = (message.schemaurl if message.schemaurl else message.schema) | schema_type( project_name, root, message.schemaformat) %}
            {%- else %}
            {%- set dataType = "object" %}
            {%- endif %}
            "{{ message.id }}": lambda: self.{{ definitionName | strip_namespace }}_async(event,
            {%- if isCloudEvent %}None, {%- endif %}
            {%- if dataType != "object" %}
            {{ dataType }}.from_data(event.body_as_str(), event.content_type)
            {%- else %}
            event.body_as_str()
            {%- endif %})
            {%- if not loop.last %}
            ,
            {%- endif %}
            {%- endfor %}
        }
        func = switcher.get(message_subject, lambda: None)
        if func:
            await func()

    @staticmethod
    def create_event_processor_client(consumer_group_name, connection_str, blob_conn_str, checkpoint_container, dispatcher):
        """
        Creates an EventProcessorClient.

        Args:
            consumer_group_name: The consumer group name.
            connection_str: The connection string for the Event Hub.
            blob_conn_str: The connection string for the Blob Storage.
            checkpoint_container: The container name for checkpoints.
            dispatcher: The dispatcher instance to handle events.

        Returns:
            An EventHubConsumerClient instance.
        """
        blob_service_client = BlobServiceClient.from_connection_string(blob_conn_str)
        container_client = blob_service_client.get_container_client(checkpoint_container)
        client = EventHubConsumerClient.from_connection_string(
            connection_str,
            consumer_group_name,
            eventhub_name=dispatcher,
            checkpoint_store=container_client
        )
        client.receive(on_event=dispatcher.process_event)
        return client

{% endfor %}

{%- if root.endpoints %}
{%- for endpoint_key in root.endpoints.keys() %}
{%- set endpoint = root.endpoints[endpoint_key] %}
{%- set pascalGroupName = endpoint.id | default(endpoint_key) | pascal %}
{%- if endpoint.usage == "consumer" %}
{%- set protocol = endpoint.config.protocol | lower %}
{%- if protocol.startswith("amqp") %}
{%- set options = endpoint.config.options %}
{%- set endpoints = endpoint.config.endpoints %}
{%- set messagegroupuris = endpoint.messagegroups %}
{%- macro MessageGroupArgs() -%}
{%- for uri in messagegroupuris %}
{%- set group = schema_object( root, uri ) %}
{%- if group %}
{%- set groupname = group.id | pascal %}
{{ groupname | strip_namespace | camel }}_dispatcher=None
{%- if not loop.last -%}, {%- endif -%}
{%- endif %}
{%- endfor %}
{%- endmacro -%}
{%- macro MessageGroupHooks(arg) -%}
tasks = [
{%- for uri in messagegroupuris %}
{%- set group = schema_object( root, uri ) %}
{% if group %}
{%- set groupname = group.id | pascal %}
{{ groupname | strip_namespace | camel }}_dispatcher.process_event({{ arg }})
{%- if not loop.last -%}, {%- endif -%}
{%- endif %}
{%- endfor %}
]
await asyncio.gather(*tasks)
{%- endmacro -%}
{%- macro createforbody(class_name, endpoints, options) -%}
    {%- set ehnamespace = geturlhost(endpoints[0].uri) -%}
    {%- set ehtopic = geturlpath(endpoints[0].uri)[1:] -%}
    fully_qualified_namespace = fully_qualified_namespace or "{{ ehnamespace }}"
    {%- if options and 'node' in options %}
    eventhub_name = eventhub_name or "{{ options['node'] }}"
    {%- elif ehtopic %}
    eventhub_name = eventhub_name or "{{ ehtopic }}"
    {%- else %}
    if eventhub_name is None:
        raise ValueError("eventhub_name cannot be None")
    {%- endif %}
    {%- if options and 'consumer_group' in options %}
    consumer_group_name = consumer_group_name or "{{ options['consumer_group'] }}"
    {%- else %}
    consumer_group_name = consumer_group_name or "$Default"
    {%- endif %}
    client = EventHubConsumerClient.from_connection_string(
        connection_str,
        consumer_group_name,
        fully_qualified_namespace=fully_qualified_namespace,
        eventhub_name=eventhub_name
    )
    client.receive(on_event=lambda event: {{ MessageGroupHooks("event") }})
    return client
{%- endmacro %}

class {{ class_name }}EventProcessorFactory:
    """
    Factory class for creating EventProcessorClient instances for {{ pascalGroupName }}.
    """

    @staticmethod
    def create_event_processor_client_for_{{ endpoint_key | pascal | strip_namespace }}(consumer_group_name, connection_str, blob_conn_str, checkpoint_container, {{ MessageGroupArgs() }}):
        """
        Creates an EventProcessorClient for {{ endpoint_key }}.

        Args:
            consumer_group_name: The consumer group name.
            connection_str: The connection string for the Event Hub.
            blob_conn_str: The connection string for the Blob Storage.
            checkpoint_container: The container name for checkpoints.
            {{ MessageGroupArgs() }}: Dispatchers for message groups.

        Returns:
            An EventHubConsumerClient instance.
        """
        return {{ createforbody(class_name, endpoints, options) }}

{%- endif %}
{%- endif %}
{%- endfor %}
{% endif %}
