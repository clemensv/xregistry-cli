{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "util.jinja.include" as util -%}
{%- set data_module_name = data_project_name | strip_invalid_identifier_characters %}
// This code was generated by the xRegistry tool.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

import * as mqtt from 'mqtt';
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = cloudEvents.usesCloudEvents(root) %}
{%- if uses_cloudevents_message %}
import { CloudEvent, HTTP } from 'cloudevents';
{%- endif %}
import { v4 as uuidv4 } from 'uuid';

// Import data types (need to compile data project first: cd ../{{ data_project_name }} && npm install && npm run build)
// NOTE: In real usage, the data project should be a proper npm package dependency
import * as {{ data_module_name }} from '../../{{ data_project_name }}/dist/index.js';

{% for messagegroupid, messagegroup in messagegroups.items() -%}
{%- set groupname = messagegroupid | pascal -%}
{%- set class_name = (groupname | strip_namespace) + "MqttClient" %}

/**
 * MQTT client for the `{{ messagegroupid }}` message group.
 */
export class {{ class_name }} {
    private client: mqtt.MqttClient;
    private mode: 'binary' | 'structured';
    private format: string;
    
    {%- for messageid, message in messagegroup.messages.items() %}
    {%- set messagename = messageid | strip_namespace | pascal %}
    {%- set message_body_type = util.body_type(data_project_name, root, message) %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    
    /**
     * Handler for {{ messagename }} messages
     {%- if message.description %}
     * {{ message.description }}
     {%- endif %}
     */
    public {{ messagename }}Handler?: ({% if isCloudEvent %}cloudEvent: CloudEvent, {% endif %}data: {{ message_body_type }}) => Promise<void>;
    {%- endfor %}
    
    /**
     * Constructor
     * @param brokerUrl The MQTT broker URL (e.g., 'mqtt://localhost:1883')
     * @param options MQTT connection options
     * @param mode CloudEvents content mode: 'binary' or 'structured' (default: 'structured')
     * @param format Content type format for structured mode (default: 'application/json')
     */
    constructor(
        brokerUrl: string, 
        options?: mqtt.IClientOptions,
        mode: 'binary' | 'structured' = 'structured',
        format: string = 'application/json'
    ) {
        this.mode = mode;
        this.format = format;
        this.client = mqtt.connect(brokerUrl, options);
        
        this.client.on('connect', () => {
            console.log('Connected to MQTT broker');
        });
        
        this.client.on('error', (error) => {
            console.error('MQTT client error:', error);
        });
        
        this.client.on('message', async (topic, message) => {
            await this.handleMessage(topic, message);
        });
    }
    
    /**
     * Subscribe to topics for all message types
     */
    async subscribe(): Promise<void> {
        return new Promise((resolve, reject) => {
            const topics: string[] = [
                {% for messageid, message in messagegroup.messages.items() -%}
                '{{ messageid }}',
                {% endfor %}
            ];
            
            this.client.subscribe(topics, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    }
    
    /**
     * Handle incoming MQTT message
     */
    private async handleMessage(topic: string, payload: Buffer): Promise<void> {
        {%- if uses_cloudevents_message %}
        // Try to parse as CloudEvent
        try {
            const result = HTTP.toEvent({ body: payload.toString(), headers: {} });
            const cloudEvent = Array.isArray(result) ? result[0] : result;
            if (cloudEvent) {
                await this.dispatchCloudEvent(cloudEvent);
                return;
            }
        } catch {
            // Not a CloudEvent, treat as plain message
        }
        {%- endif %}
        
        await this.dispatchMessage(topic, payload);
    }
    
    {%- if uses_cloudevents_message %}
    
    /**
     * Dispatch a CloudEvent message
     */
    private async dispatchCloudEvent(cloudEvent: CloudEvent<unknown>): Promise<void> {
        const cloudEventType = cloudEvent.type;
        
        switch (cloudEventType) {
            {% for messageid, message in messagegroup.messages.items() -%}
            {%- set messagename = messageid | pascal | strip_namespace %}
            {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
            {%- set message_body_type = util.body_type(data_project_name, root, message) %}
            {%- if isCloudEvent %}
            case '{{ messageid }}':
                if (this.{{ messagename }}Handler && cloudEvent.data) {
                    const data = cloudEvent.data as unknown as {{ message_body_type }};
                    await this.{{ messagename }}Handler(cloudEvent, data);
                }
                break;
            {%- endif %}
            {% endfor %}
            default:
                break;
        }
    }
    {%- endif %}
    
    /**
     * Dispatch a plain MQTT message
     */
    private async dispatchMessage(topic: string, payload: Buffer): Promise<void> {
        switch (topic) {
            {% for messageid, message in messagegroup.messages.items() if not cloudEvents.isCloudEvent(message) -%}
            {%- set messagename = messageid | pascal | strip_namespace %}
            {%- set message_body_type = util.body_type(data_project_name, root, message) %}
            case '{{ messageid }}':
                if (this.{{ messagename }}Handler) {
                    const data = JSON.parse(payload.toString()) as {{ message_body_type }};
                    await this.{{ messagename }}Handler(data);
                }
                break;
            {% endfor %}
            default:
                break;
        }
    }
    
    {% for messageid, message in messagegroup.messages.items() -%}
    {%- set messagename = messageid | pascal | strip_namespace %}
    {%- set isCloudEvent = cloudEvents.isCloudEvent(message) %}
    {%- set type_name = util.body_type(data_project_name, root, message) %}
    
    /**
     * Publish the `{{ messagename }}` message
     {%- if message.description %}
     * {{ message.description }}
     {%- endif %}
     * @param data The message data object
     {%- if isCloudEvent %}
     {%- for attrname in ['source', 'type'] if attrname not in message.envelopemetadata %}
     * @param {{ attrname }} CloudEvent required attribute '{{ attrname }}'
     {%- endfor %}
     {%- for attrname, attribute in message.envelopemetadata.items() if attribute.type == "uritemplate" %}
     {%- for placeholder in attribute.value | regex_search('\\{([A-Za-z0-9_]+)\\}') %}
     * @param {{ placeholder }} Value for placeholder {{ placeholder }} in attribute {{ attrname }}
     {%- endfor %}
     {%- endfor %}
     {%- for attrname, attribute in message.envelopemetadata.items() if attribute.value is not defined and attrname not in ["time", "id", "datacontenttype", "dataschema"] %}
     * @param {{ attrname }} CloudEvent {{ attrname }} attribute{% if not attribute.required %} (optional){% endif %}
     {%- endfor %}
     {%- endif %}
     * @returns Promise that resolves when the message is published
     */
    async publish{{ messagename }}(
        data: {{ type_name }},
        {%- if isCloudEvent %}
        {%- for attrname in ['source', 'type'] if attrname not in message.envelopemetadata %}
        {{ attrname }}: string,
        {%- endfor %}
        {%- for attrname, attribute in message.envelopemetadata.items() if attribute.type == "uritemplate" %}
        {%- for placeholder in attribute.value | regex_search('\\{([A-Za-z0-9_]+)\\}') %}
        {{ placeholder }}: string,
        {%- endfor %}
        {%- endfor %}
        {%- for attrname, attribute in message.envelopemetadata.items() if attribute.value is not defined and attrname not in ["time", "id", "datacontenttype", "dataschema"] %}
        {{ attrname }}{% if not attribute.required %}?{% endif %}: string,
        {%- endfor %}
        {%- endif %}
    ): Promise<void> {
        return new Promise((resolve, reject) => {
            {%- if isCloudEvent %}
            const cloudEvent = new CloudEvent({
            {%- for attrname in ['source', 'type'] if attrname not in message.envelopemetadata %}
            {%- if attrname == "type" %}
                type: {{ attrname }},
            {%- elif attrname == "source" %}
                source: {{ attrname }},
            {%- endif %}
            {%- endfor %}
            {%- for attrname, attribute in message.envelopemetadata.items() %}
            {%- if attrname == "type" %}
                type: {% if attribute.value %}'{{ attribute.value }}'{% else %}{{ attrname }}{% endif %},
            {%- elif attrname == "source" %}
                source: {% if attribute.value %}{% if attribute.type == "uritemplate" %}`{{ attribute.value | regex_replace('\\{([A-Za-z0-9_]+)\\}', '${\\1}') }}`{% else %}'{{ attribute.value }}'{% endif %}{% else %}{{ attrname }} || '/client'{% endif %},
            {%- elif attrname in ["id", "time"] %}
                {# id and time are auto-generated #}
            {%- elif attrname == "datacontenttype" %}
                {# handled separately #}
            {%- elif attrname == "dataschema" %}
                {# handled separately if needed #}
            {%- elif attribute.value %}
                {{ attrname }}: {% if attribute.type == "uritemplate" %}`{{ attribute.value | regex_replace('\\{([A-Za-z0-9_]+)\\}', '${\\1}') }}`{% else %}'{{ attribute.value }}'{% endif %},
            {%- else %}
                {% if not attribute.required %}...({{ attrname }} && { {{ attrname }} }),{% else %}{{ attrname }},{% endif %}
            {%- endif %}
            {%- endfor %}
                id: uuidv4(),
                data: data,
                datacontenttype: 'application/json'
            });
            
            let payload: string;
            let properties: mqtt.IClientPublishOptions = {};
            
            if (this.mode === 'structured') {
                payload = JSON.stringify(cloudEvent.toJSON());
                properties.properties = {
                    contentType: this.format
                };
            } else {
                // Binary mode - CloudEvent attributes as MQTT properties
                payload = JSON.stringify(data);
                const userProperties: Record<string, string> = {
                    'content-type': 'application/json',
                    'ce_specversion': '1.0',
                    'ce_id': cloudEvent.id,
                    'ce_type': cloudEvent.type,
                    'ce_source': cloudEvent.source
                };
                if (cloudEvent.subject) userProperties['ce_subject'] = cloudEvent.subject;
                if (cloudEvent.time) userProperties['ce_time'] = cloudEvent.time;
                {%- for attrname, attribute in message.envelopemetadata.items() if attrname not in ["id", "type", "source", "subject", "time", "specversion", "datacontenttype", "dataschema", "data"] %}
                if ((cloudEvent as any).{{ attrname }}) userProperties['ce_{{ attrname }}'] = (cloudEvent as any).{{ attrname }};
                {%- endfor %}
                properties.properties = {
                    contentType: 'application/json',
                    userProperties
                };
            }
            {%- else %}
            const payload = JSON.stringify(data);
            const properties: mqtt.IClientPublishOptions = {};
            {%- endif %}
            
            this.client.publish('{{ messageid }}', payload, properties, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    }
    {% endfor %}
    
    /**
     * Close the MQTT client
     */
    async close(): Promise<void> {
        return new Promise((resolve) => {
            this.client.end(false, {}, () => {
                resolve();
            });
        });
    }
}
{% endfor %}
